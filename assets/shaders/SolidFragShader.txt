#version 460 core

struct Material{
	vec3 ambient;
	vec3 diffuse;
	sampler2D specular;
	float specularIntensity;
	float shininess;
};

struct Light
{
	vec3 color;
	//vec3 position;
	vec4 vector;
	vec3 ambient;
	float ambientIntensity;
	vec3 diffuse;
	vec3 specular;
};

in vec2 fTexCoord;
in vec3 fNormalVec;
in vec3 FragPos; // Use vertex WS coords to determine frag position

out vec4 FragColor;

uniform Material fMaterial;
uniform Light fLight;

uniform vec3 fLightPosition;
uniform vec3 fViewPosition;

void main()
{
	// Ambient lighting contribution:
	vec3 ambient = fLight.ambient * fMaterial.diffuse * fLight.ambientIntensity;

	// Diffuse contribution:
	// Never forget to normalize vectors used in light calculations
	vec3 normalizedNormal = normalize(fNormalVec);	// Normalize normal
	vec3 lightDirection;
	if(fLight.vector.w == 1) // Is position
	{
		lightDirection = normalize(fLight.vector.xyz - FragPos); // Normalize light direction
	}
	else if(fLight.vector.w == 0) // Is direction
	{
		lightDirection = normalize(-(fLight.vector.xyz)); // Normalize light direction
	}

	float diffuseFactor = max(dot(normalizedNormal, fLight.vector.xyz), 0.0); // max(x, y) to avoid negative factors
	//vec3 diffuse = fLightColor * diffuseFactor * fMaterial.diffuse;
	vec3 diffuse = fLight.diffuse * diffuseFactor * fMaterial.diffuse;

	// Specular contribution:
	vec3 viewDir = normalize(fViewPosition - FragPos);
	vec3 reflectionDir = reflect(-lightDirection, normalizedNormal);
	float specular = pow(max(dot(viewDir, reflectionDir), 0.0), fMaterial.shininess);
	vec3 specularVector = vec3(texture(fMaterial.specular, fTexCoord)) * specular * fLight.specular * fMaterial.specularIntensity;

	vec3 result = (ambient + diffuse + specularVector) * 2; // Times 2 to exagerate the effect
	FragColor = vec4(result, 1.0);
}